package Fridfiltrator.poller;

import Fridfiltrator.helpers.Logger;
import com.macasaet.fernet.Key;
import com.macasaet.fernet.StringValidator;
import com.macasaet.fernet.Token;
import com.macasaet.fernet.Validator;
import jakarta.xml.bind.DatatypeConverter;
import java.time.Duration;
import java.time.temporal.TemporalAmount;
import java.util.List;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;

public abstract class Poller {

    private ScheduledThreadPoolExecutor scheduledThreadPoolExecutor;
    private ScheduledFuture<?> schedule;

    /**
     * Performs a health check on the poller.
     * This task runs synchronously, so it's recommended to run it inside a
     * thread, like: {@code new Thread ( () -> poller.healthcheck() ).start ();}
     * 
     * @param logger
     *              Lambda to control what happens with the debugging messages
     *          generated by the poller.
     * 
     * @return
     *              {@code true} if the checks passed, or {@code false} if
     *          something failed.
     * 
     * @throws Exception
     *              Different exceptions depending on the implementor.
     */
    public abstract boolean healthCheck (Consumer<String> logger) throws Exception;

    /**
     * Polls the server to see if there's any data and, if any, returns it as
     * a list of byte array, which is the raw data retrieved from the redirector.
     * 
     * @param logger
     *              Lambda to control what happens with the debugging messages
     *          generated by the poller.
     * 
     * @return
     *              A list with the retrieved events. This list might be empty,
     *          but never {@code null}.
     */
    protected abstract List<byte []> poll (Consumer<String> logger);

    /**
     * Starts the poller as a new thread.
     * 
     * @param logger
     *              Function to control what happens with the debugging messages
     *          generated by the poller.
     * 
     * @param handler
     *              Function to handle the event triggered when some data is
     *          recovered by the poller. The parameter that will be applied is
     *          the raw decrypted string, with no further processing (i.e.: if
     *          it's JSON or whatever, the handler must parse it if needed).
     */
    public void start (Consumer<String> logger, Consumer<String> handler) {

        scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor (1);
        schedule = scheduledThreadPoolExecutor.scheduleAtFixedRate (
            new PollingRunnable (logger, handler),
            0,
            5,
            TimeUnit.SECONDS
        );

        logger.accept ("Started polling every 5 seconds");
    }

    /**
     * Stops the thread running the poller
     */
    public void stop () {

        /* `schedule` is instantiated from scheduledThreadPoolExecutor`, so
        there's no need to check if the threadPoolExecutor is also not-null */
        if (schedule != null) {

            schedule.cancel (true);
            scheduledThreadPoolExecutor.shutdown ();
            Logger.getLogger ().log ("Poller stopped");
        }
    }

    /**
     * Checks if the polling thread is running.
     * 
     * @return 
     *              {@code true} if the polling thread is running,
     *          {@code false} otherwise.
     */
    public boolean isRunning () {

        return (schedule != null)
                && schedule.state ().equals (Future.State.RUNNING);
    }

    
    /**************************************/
    /**************************************/
    /**************************************/
    
    
    /**
     * Internal class to manage the polling process as a separate thread
     */
    protected class PollingRunnable implements Runnable {

        // Hardcoded for testing
        private final Key encryption_key = new Key ("0KET_f5D_YcaSQicPfhEUJG0aIYDps0sFkgcj_BC9fQ=");

        private final Validator<String> validator;
        
        private final Consumer<String> logger;
        
        private final Consumer<String> handler;
        
        /**
         * Constructor.
         * 
         * @param logger
         *              Function to control what happens with the debugging
         *          messages generated by the poller.
         * 
         * @param handler
         *              Handler to trigger when an event is decrypted.
         */
        public PollingRunnable (Consumer<String> logger, Consumer<String> handler) {

            this.validator = new StringValidator () {
                @Override
                public TemporalAmount getTimeToLive() {
                    return Duration.ofHours (9999); // Outrageous duration for testing
                }
            };

            this.logger = logger;
            this.handler = handler;
        }

        /**
         * Decrypts the event and prints it out using {@link PollingRunnable#logger}
         */
        private void processEvent (byte[] data) {
            logger.accept (
                    "Got event data: "
                    + DatatypeConverter.printHexBinary (data)
            );

            try {
                Token fernet_token = Token.fromBytes (data);
                String dec_data = fernet_token.validateAndDecrypt (encryption_key, validator);

                handler.accept (dec_data);

            } catch (Exception ex) {

                logger.accept (ex.getLocalizedMessage ());
            }
        }

        @Override
        public void run () {

            logger.accept ("\n=============\n\nPaul'ing...");

            List<byte[]> resp_data = poll (logger);
            resp_data.forEach (e -> processEvent (e));
        }
    }

}
